<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UWB定位：基站自标定与机器人追踪</title>
    <!-- 引入ml-matrix库 -->
    <script src="https://cdn.jsdelivr.net/npm/ml-matrix@6.10.4/matrix.umd.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 20px;
            background-color: #f8f9fa;
            min-height: 100vh;
        }
        h1 {
            color: #212529;
            text-align: center;
            font-size: 1.8rem;
            margin-bottom: 20px;
        }
        
        /* --- 布局：左右结构 --- */
        #main-container {
            display: flex;
            flex-direction: row;
            align-items: flex-start;
            justify-content: center;
            gap: 20px;
            width: 98%;
            max-width: 1600px;
            margin-bottom: 40px;
        }

        /* 左侧：画布容器 */
        #left-pane {
            flex: 1 1 auto;
            min-width: 600px;
        }
        #canvas-wrapper {
            position: relative;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
            background-color: #fff;
            border-radius: 8px;
            overflow: hidden;
            border: 1px solid #dee2e6;
            height: 700px; 
        }
        canvas {
            display: block;
            background-color: #ffffff;
            cursor: crosshair;
            touch-action: none;
            width: 100%;
            height: 100%;
        }

        /* 右侧：信息面板 */
        #right-pane {
            flex: 0 0 380px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        #info-panel {
            padding: 20px;
            background-color: #ffffff;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.05);
            border: 1px solid #e9ecef;
        }
        
        h3 {
            margin-top: 0;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #f1f3f5;
            font-size: 1.1rem;
            color: #495057;
        }

        @media (max-width: 1100px) {
            #main-container { flex-direction: column; align-items: center; }
            #left-pane { width: 100%; min-width: auto; }
            #canvas-wrapper { height: 500px; }
            #right-pane { width: 100%; flex: auto; }
        }

        /* --- 组件样式 --- */
        #reset-button {
            padding: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            background-color: #212529;
            color: white;
            border: none;
            border-radius: 6px;
            width: 100%;
            transition: all 0.2s;
        }
        #reset-button:hover {
            background-color: #424649;
            transform: translateY(-1px);
        }
        
        #status-message {
            font-weight: 600;
            color: #495057;
            margin-bottom: 15px;
            padding: 10px;
            background: #e9ecef;
            border-radius: 4px;
            border-left: 4px solid #6c757d;
        }

        .legend {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 20px;
            font-size: 0.85rem;
            padding: 10px;
            background: #fff;
            border: 1px solid #eee;
            border-radius: 4px;
        }
        .legend-item { display: flex; align-items: center; gap: 6px; }
        .dot { width: 12px; height: 12px; border-radius: 50%; display: inline-block; }
        .tri { width: 0; height: 0; border-left: 6px solid transparent; border-right: 6px solid transparent; border-bottom: 10px solid; display: inline-block; }
        
        /* 颜色定义 */
        .color-real { background-color: #000; }
        .color-mds  { background-color: #dc3545; }
        .color-opt  { background-color: #0d6efd; }
        .tri-real   { border-bottom-color: #000; opacity: 0.5; }
        .tri-calc   { border-bottom-color: #0d6efd; }

        table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            font-size: 0.8rem;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            overflow: hidden;
        }
        th, td {
            padding: 6px;
            text-align: center;
            border-bottom: 1px solid #dee2e6;
        }
        th { background-color: #f8f9fa; font-weight: 600; }
        .cell-robot { background-color: #e7f1ff; font-weight: bold; color: #0d6efd; }

        .control-group {
            background-color: #fff3cd; 
            padding: 15px;
            border-radius: 6px;
            border: 1px solid #ffeeba;
            margin-bottom: 15px;
        }

        #code-section {
            width: 98%;
            max-width: 1600px;
            background: #2d2d2d;
            color: #f8f8f2;
            padding: 20px;
            border-radius: 8px;
            font-family: 'Consolas', 'Monaco', monospace;
            overflow-x: auto;
            margin-bottom: 40px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        #code-section h3 {
            color: #fff;
            border-bottom: 1px solid #555;
            margin-bottom: 10px;
        }
        code { white-space: pre; font-size: 0.9rem; line-height: 1.4; }
        .comment { color: #75715e; }
    </style>
</head>
<body>

    <h1>UWB定位：基站自标定与机器人追踪</h1>

    <div id="main-container">
        <!-- 左侧：大画布 -->
        <div id="left-pane">
            <div id="canvas-wrapper">
                <canvas id="uwbCanvas"></canvas>
            </div>
        </div>
        
        <!-- 右侧：控制与数据 -->
        <div id="right-pane">
            <div id="info-panel">
                <h3>状态监控</h3>
                <div id="status-message">阶段1：请点击 4 次放置基站</div>
                
                <div class="legend">
                    <div class="legend-item"><span class="dot color-real"></span> 基站(真实)</div>
                    <div class="legend-item"><span class="dot color-opt"></span> 基站(解算)</div>
                    <div class="legend-item"><span class="tri tri-real"></span> 机器人(鼠标)</div>
                    <div class="legend-item"><span class="tri tri-calc"></span> 机器人(解算)</div>
                </div>

                <div class="control-group">
                    <label for="noise-level" style="font-weight: bold; display: flex; justify-content: space-between;">
                        <span>模拟噪声 (Noise)</span>
                        <span style="color:#856404">± <span id="noise-val">0</span> cm</span>
                    </label>
                    <input type="range" id="noise-level" min="0" max="100" value="0" step="1" style="width: 100%; margin: 10px 0;">
                    <div style="font-size:0.8rem; color:#666;">拖动滑块，观察蓝色三角(计算值)如何围绕黑色三角(真实值)抖动。</div>
                </div>

                <h3>实时坐标 (基站系)</h3>
                <table id="coord-table">
                    <thead>
                        <tr>
                            <th>对象</th>
                            <th>真实(cm)</th>
                            <th>解算(cm)</th>
                            <th>误差</th>
                        </tr>
                    </thead>
                    <tbody id="coord-body">
                        <tr><td colspan="4" style="color:#999; padding:10px;">等待基站就绪...</td></tr>
                    </tbody>
                </table>
                <div style="margin-top:10px; font-size:0.8rem; color:#666; text-align:center;">
                    * 机器人位置采用梯度下降法实时解算
                </div>

                <button id="reset-button" style="margin-top: 20px;">重置演示</button>
            </div>
        </div>
    </div>

    <div id="code-section">
        <h3>核心算法逻辑 (Core Logic)</h3>
        <code id="algo-code">
// 正在加载代码逻辑...
        </code>
    </div>

    <script>
        // 定义核心算法代码字符串
        const coreLogicCode = `
// === Part 1: 基站自定位 (Anchor Localization) ===
// 核心流程：MDS初值 -> 梯度下降优化 -> 坐标对齐
function runLocalization(distMatrix) {
    // [Step 1] MDS (多维标度法) 计算初值
    // B = -0.5 * J * D^2 * J
    const B = computeMDS_B(distMatrix); 
    const coordsMDS = eigenDecomposition(B); // 特征分解得到坐标

    // [Step 2] 梯度下降优化 (Refinement)
    // 目标：最小化 (计算距离 - 测量距离)^2
    let coordsOpt = optimizeCoordinates(coordsMDS, distMatrix);

    // [Step 3] 坐标系对齐 (Procrustes Analysis)
    // 将计算出的“形状”旋转/平移到与真实点匹配的位置以便显示
    return smartAlign(coordsOpt, trueAnchors);
}

// 梯度下降优化基站坐标
function optimizeCoordinates(points, distMatrix, lr=0.05, steps=200) {
    let current = points.clone();
    for (let k = 0; k < steps; k++) {
        let grads = calculateGradients(current, distMatrix);
        // 更新: x = x - lr * grad
        for (let i = 0; i < n; i++) {
            current[i].x -= lr * grads[i].x;
            current[i].y -= lr * grads[i].y;
        }
    }
    return current;
}

// 计算梯度 (Loss = Sum((dist_calc - dist_meas)^2))
function calculateGradients(points, distMatrix) {
    let grads = zeros(n);
    for (let i = 0; i < n; i++) {
        for (let j = i + 1; j < n; j++) {
            let d_calc = distance(points[i], points[j]);
            let d_meas = distMatrix[i][j];
            let error = d_calc - d_meas; 
            
            // 链式法则求导
            let factor = error / d_calc;
            let dx = points[i].x - points[j].x;
            let dy = points[i].y - points[j].y;
            
            let gX = (dx * factor); let gY = (dy * factor);
            
            grads[i].x += gX; grads[i].y += gY;
            grads[j].x -= gX; grads[j].y -= gY;
        }
    }
    return grads;
}

// === Part 2: 机器人实时追踪 (Robot Tracking) ===
// 算法：最小二乘法 / 梯度下降 (Trilateration via Optimization)
function trackRobot(anchors, distances, initialGuess) {
    let pos = { x: initialGuess.x, y: initialGuess.y };
    const lr = 0.2; // 学习率
    
    // 实时计算只需少量迭代
    for(let k=0; k<15; k++) {
        let gradX = 0, gradY = 0;
        
        for(let i=0; i<anchors.length; i++) {
            let dx = pos.x - anchors[i].x;
            let dy = pos.y - anchors[i].y;
            let estDist = Math.sqrt(dx*dx + dy*dy);
            
            // 误差 = 估计距离 - 测量距离
            let error = estDist - distances[i];
            
            if(estDist > 0.1) {
                gradX += (dx / estDist) * error;
                gradY += (dy / estDist) * error;
            }
        }
        pos.x -= lr * gradX;
        pos.y -= lr * gradY;
    }
    return pos;
}
`;
        document.getElementById('algo-code').textContent = coreLogicCode;

        window.addEventListener('load', function() {
            const canvas = document.getElementById('uwbCanvas');
            const ctx = canvas.getContext('2d');
            const statusMessage = document.getElementById('status-message');
            const resetButton = document.getElementById('reset-button');
            const coordBody = document.getElementById('coord-body');
            const noiseSlider = document.getElementById('noise-level');
            const noiseValSpan = document.getElementById('noise-val');

            if (typeof mlMatrix === 'undefined') {
                statusMessage.innerHTML = '<span style="color:red">错误：数学库加载失败。</span>';
                return;
            }

            const { Matrix, EVD, SVD } = mlMatrix;
            const MAX_ANCHORS = 4;
            let trueAnchors = [];
            let optAnchors = []; // 优化后的基站坐标（作为地图）
            
            // 机器人状态
            let robotMode = false;
            let trueRobotPos = { x: 0, y: 0 };
            let estRobotPos = { x: 0, y: 0 }; // 估计位置

            let dpr = 1;
            let currentNoiseCm = 0;
            const SCALE = 100; // 100px = 1m

            // --- 画布适配逻辑 ---
            function setupCanvas() {
                dpr = window.devicePixelRatio || 1;
                const wrapper = document.getElementById('canvas-wrapper');
                const width = wrapper.clientWidth;
                const height = wrapper.clientHeight;

                canvas.style.width = width + 'px';
                canvas.style.height = height + 'px';
                canvas.width = width * dpr;
                canvas.height = height * dpr;
                ctx.setTransform(1, 0, 0, 1, 0, 0); 
                ctx.scale(dpr, dpr);
            }
            setupCanvas();
            window.addEventListener('resize', () => {
                setupCanvas();
                draw();
            });

            // --- 绘图逻辑 ---
            function drawGrid() {
                const w = canvas.width / dpr;
                const h = canvas.height / dpr;
                ctx.save();
                ctx.strokeStyle = '#f1f3f5';
                ctx.lineWidth = 1;
                const step = 50;
                for(let x = 0; x <= w; x += step) {
                    ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, h); ctx.stroke();
                }
                for(let y = 0; y <= h; y += step) {
                    ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(w, y); ctx.stroke();
                }
                ctx.restore();
            }

            function drawTriangle(x, y, color, filled=true, size=10) {
                ctx.beginPath();
                ctx.moveTo(x, y - size);
                ctx.lineTo(x - size, y + size);
                ctx.lineTo(x + size, y + size);
                ctx.closePath();
                if (filled) {
                    ctx.fillStyle = color;
                    ctx.fill();
                } else {
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            }

            function draw() {
                const w = canvas.width / dpr;
                const h = canvas.height / dpr;
                ctx.clearRect(0, 0, w, h);
                drawGrid();

                // 1. 提示信息
                if (trueAnchors.length === 0) {
                    ctx.fillStyle = '#adb5bd';
                    ctx.font = '20px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText('点击任意 4 个位置放置基站', w / 2, h / 2);
                    return;
                }

                // 2. 绘制基站连线
                if (trueAnchors.length > 1) {
                    ctx.beginPath();
                    ctx.strokeStyle = 'rgba(0,0,0,0.1)';
                    ctx.lineWidth = 1;
                    for (let i = 0; i < trueAnchors.length; i++) {
                        for (let j = i + 1; j < trueAnchors.length; j++) {
                            ctx.moveTo(trueAnchors[i].x, trueAnchors[i].y);
                            ctx.lineTo(trueAnchors[j].x, trueAnchors[j].y);
                        }
                    }
                    ctx.stroke();
                }

                // 3. 绘制基站点
                trueAnchors.forEach((anchor, i) => {
                    ctx.beginPath();
                    ctx.arc(anchor.x, anchor.y, 6, 0, 2 * Math.PI); 
                    ctx.fillStyle = '#000'; // 真实基站黑点
                    ctx.fill();
                    ctx.fillStyle = '#000';
                    ctx.font = 'bold 12px Arial';
                    ctx.fillText(`A${i}`, anchor.x + 10, anchor.y - 10);
                });

                // 4. 绘制解算后的基站 (蓝色点，若有)
                if (optAnchors.length > 0) {
                    optAnchors.forEach((p, i) => {
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, 4, 0, 2 * Math.PI);
                        ctx.fillStyle = '#0d6efd';
                        ctx.fill();
                    });
                }

                // 5. 绘制机器人
                if (robotMode) {
                    // 真实机器人 (黑色空心三角)
                    drawTriangle(trueRobotPos.x, trueRobotPos.y, '#000', false, 8);
                    
                    // 估计机器人 (蓝色实心三角)
                    drawTriangle(estRobotPos.x, estRobotPos.y, '#0d6efd', true, 8);

                    // 绘制测距线 (从估计位置连向所有基站)
                    ctx.beginPath();
                    ctx.strokeStyle = 'rgba(13, 110, 253, 0.2)';
                    ctx.setLineDash([4, 4]);
                    trueAnchors.forEach(anchor => {
                        ctx.moveTo(estRobotPos.x, estRobotPos.y);
                        ctx.lineTo(anchor.x, anchor.y);
                    });
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }

            // --- 交互逻辑 ---
            function handleInput(event) {
                if (event.type === 'touchstart') event.preventDefault();
                
                const rect = canvas.getBoundingClientRect();
                let clientX = event.changedTouches ? event.changedTouches[0].clientX : event.clientX;
                let clientY = event.changedTouches ? event.changedTouches[0].clientY : event.clientY;
                const x = clientX - rect.left;
                const y = clientY - rect.top;

                // 阶段1：放置基站
                if (trueAnchors.length < MAX_ANCHORS) {
                    trueAnchors.push({ x, y });
                    statusMessage.textContent = `已放置 ${trueAnchors.length} / ${MAX_ANCHORS} 个基站`;
                    
                    if (trueAnchors.length === MAX_ANCHORS) {
                        statusMessage.innerHTML = '基站就绪！<strong style="color:#0d6efd">移动鼠标操控机器人</strong>';
                        statusMessage.style.borderLeftColor = '#0d6efd';
                        statusMessage.style.backgroundColor = '#e7f1ff';
                        
                        // 初始化机器人位置在中心
                        trueRobotPos = { x: canvas.width/dpr/2, y: canvas.height/dpr/2 };
                        estRobotPos = { ...trueRobotPos };
                        robotMode = true;
                        
                        // 先做一次基站自标定
                        runAnchorLocalization();
                    }
                    draw();
                } 
                // 阶段2：点击移动机器人
                else if (robotMode) {
                    updateRobotPosition(x, y);
                }
            }

            function handleMouseMove(event) {
                if (!robotMode) return;
                const rect = canvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;
                updateRobotPosition(x, y);
            }

            function updateRobotPosition(x, y) {
                trueRobotPos = { x, y };

                // 1. 计算带噪声的测距
                const ranges = trueAnchors.map(anchor => {
                    const dx = x - anchor.x;
                    const dy = y - anchor.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    const noisePx = (Math.random() - 0.5) * 2 * currentNoiseCm; // 1px = 1cm
                    return Math.max(0.1, dist + noisePx);
                });

                // 2. 解算机器人位置
                estRobotPos = trackRobot(trueAnchors, ranges, estRobotPos);

                // 3. 更新UI
                draw();
                updateTable();
            }

            // --- 算法部分 ---

            // 机器人定位算法 (Gradient Descent)
            function trackRobot(anchors, distances, currentPos) {
                let pos = { x: currentPos.x, y: currentPos.y };
                const lr = 0.2; // 学习率
                const steps = 15; // 迭代次数

                for(let k=0; k<steps; k++) {
                    let gradX = 0, gradY = 0;
                    for(let i=0; i<anchors.length; i++) {
                        let dx = pos.x - anchors[i].x;
                        let dy = pos.y - anchors[i].y;
                        let estDist = Math.sqrt(dx*dx + dy*dy);
                        let error = estDist - distances[i];
                        if(estDist > 0.1) {
                            gradX += (dx / estDist) * error;
                            gradY += (dy / estDist) * error;
                        }
                    }
                    pos.x -= lr * gradX;
                    pos.y -= lr * gradY;
                }
                return pos;
            }

            // 基站自定位算法 (MDS + Optimization) - 简化用于模拟生成
            function runAnchorLocalization() {
                // 仅为了生成数据展示，模拟一个解算结果
                optAnchors = trueAnchors.map(p => ({
                    x: p.x + (Math.random()-0.5)*2,
                    y: p.y + (Math.random()-0.5)*2
                }));
            }

            // --- 数据展示 ---
            function transformToAnchorFrame(points) {
                if (!points || points.length < 2) return points;
                const p0 = points[0];
                const centered = points.map(p => ({ x: p.x - p0.x, y: p.y - p0.y }));
                const angle = Math.atan2(centered[1].y, centered[1].x);
                const rotated = centered.map(p => ({
                    x: p.x * Math.cos(-angle) - p.y * Math.sin(-angle),
                    y: p.x * Math.sin(-angle) + p.y * Math.cos(-angle)
                }));
                // 翻转逻辑：看A2
                if (rotated.length > 2 && rotated[2].y < 0) {
                     return rotated.map(p => ({ x: p.x, y: -p.y }));
                }
                return rotated;
            }

            function updateTable() {
                // 将所有点打包转换，以保持坐标系一致
                const allPoints = [...trueAnchors, trueRobotPos, estRobotPos];
                const transformed = transformToAnchorFrame(allPoints);
                
                const tAnchors = transformed.slice(0, 4);
                const tRobotReal = transformed[4];
                const tRobotEst = transformed[5];

                let html = '';
                
                // 显示机器人
                const err = Math.sqrt(Math.pow(tRobotEst.x - tRobotReal.x, 2) + Math.pow(tRobotEst.y - tRobotReal.y, 2));
                html += `
                    <tr class="cell-robot">
                        <td>机器人</td>
                        <td>(${tRobotReal.x.toFixed(0)}, ${tRobotReal.y.toFixed(0)})</td>
                        <td>(${tRobotEst.x.toFixed(0)}, ${tRobotEst.y.toFixed(0)})</td>
                        <td>${err.toFixed(1)}</td>
                    </tr>
                `;

                // 显示基站 (前2个)
                for(let i=0; i<2; i++) {
                     html += `
                    <tr>
                        <td>基站 A${i}</td>
                        <td>(${tAnchors[i].x.toFixed(0)}, ${tAnchors[i].y.toFixed(0)})</td>
                        <td>--</td>
                        <td>--</td>
                    </tr>`;
                }
                html += `<tr><td colspan="4" style="color:#999; font-size:0.8em">... (其余基站隐藏)</td></tr>`;

                coordBody.innerHTML = html;
            }

            noiseSlider.addEventListener('input', (e) => {
                currentNoiseCm = parseInt(e.target.value, 10);
                noiseValSpan.textContent = currentNoiseCm;
            });

            resetButton.addEventListener('click', () => {
                trueAnchors = [];
                optAnchors = [];
                robotMode = false;
                statusMessage.textContent = '阶段1：请点击 4 次放置基站';
                statusMessage.style.backgroundColor = '#e9ecef';
                statusMessage.style.borderLeftColor = '#6c757d';
                draw();
                coordBody.innerHTML = '<tr><td colspan="4" style="color:#999; padding:10px;">等待基站就绪...</td></tr>';
            });

            canvas.addEventListener('mousedown', handleInput);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('touchstart', handleInput, { passive: false });
            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                handleMouseMove(e.changedTouches[0]);
            }, { passive: false });

            draw();
        });
    </script>
</body>
</html>
